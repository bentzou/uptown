#!/bin/bash

# Uptown â€” navigate your directory hierarchy with Alt+Arrow keys.
# https://github.com/bentzou/uptown


##### Configuration #####

# Uptown works by converting your keyboard shortcuts, like opt+up arrow and
#   opt+down arrow, into unused escape sequences, which are then converted
#   into commands that shell navigation commands. This can be tricky!
#
# The escape sequences depend on your terminal application. iTerm uses the
#   modifier 9 (esc + [1;9A), while most other terminals (Ghostty, kitty, etc.)
#   use the standard xterm modifier 3 (esc + [1;3A). You may need to update
#   the below variables to match the escape sequences your terminal sends.

if [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
   UPTOWN_UP_KEY_SEQUENCE='\e[1;9A'
   UPTOWN_DOWN_KEY_SEQUENCE='\e[1;9B'
else
   UPTOWN_UP_KEY_SEQUENCE='\e[1;3A'
   UPTOWN_DOWN_KEY_SEQUENCE='\e[1;3B'
fi

# Uptown automatically uses the paths in UPTOWN_DEFAULT_PATHS when possible.
#   Feel free to add your own.

UPTOWN_DEFAULT_PATHS=(
   "$HOME"
)


##### Script options #####

#set -o nounset


##### Methods #####

uptown_init () {
   [[ "${PROMPT_COMMAND:-}" != *uptown_update_path* ]] && \
      PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND;}uptown_update_path"
   bind '"'$UPTOWN_UP_KEY_SEQUENCE'": "cdu\n"'
   bind '"'$UPTOWN_DOWN_KEY_SEQUENCE'": "cdd\n"'
}

uptown_update_path () {
   if ! uptown_is_subpath "$PWD" "${UPTOWN_PATH:-}"; then
      local default_path=$(uptown_find_default_path_match "$PWD")

      if [ -n "$default_path" ]; then
         UPTOWN_PATH="$default_path"
      else
         UPTOWN_PATH="$PWD"
      fi
   fi
}

uptown_find_default_path_match () {
   [ -z "${UPTOWN_DEFAULT_PATHS:-}" ] && return

   local path norm_path
   for path in "${UPTOWN_DEFAULT_PATHS[@]}"; do
      norm_path=${path/\~/$HOME}
      uptown_is_subpath "$1" "$norm_path" && echo "$norm_path" && return
   done
}

uptown_is_subpath () {
   local -a new
   IFS='/' read -r -a new <<< "$1"

   local match=$(uptown_count_path_match "$1" "$2")
   (( match == ${#new[@]}-1 ))
}

uptown_count_path_match () {
   local -a new cur
   IFS='/' read -r -a new <<< "$1"
   IFS='/' read -r -a cur <<< "$2"

   local index=1
   while (( index < ${#new[@]} && index < ${#cur[@]} )); do
      [ "${cur[index]}" = "${new[index]}" ] && (( ++index )) || break
   done
   echo $((index-1))
}

uptown_get_only_child_path () {
   local paths=(*/)
   (( ${#paths[@]} == 1 )) && [ -d "${paths[0]}" ] && echo "${paths[0]}"
}

uptown_get_child_path () {
   local child_path=$(uptown_get_only_child_path)
   if [ -z "$child_path" ]; then
      local path_idx=$(uptown_count_path_match "$PWD" "$UPTOWN_PATH")
      child_path=$(uptown_subpath_by_idx $((path_idx+1)))
   fi
   echo "$child_path"
}

uptown_subpath_by_idx () {
   (( $1 == 0 )) && echo -n "/" && return

   local -a cur
   IFS='/' read -r -a cur <<< "$UPTOWN_PATH"
   echo -n "$(printf "/%s" "${cur[@]:0:$1+1}" | cut -c2-)"
}

cdu () {
   builtin cd ..
}

cdd () {
   builtin cd "$(uptown_get_child_path)"
}

uptown_init
